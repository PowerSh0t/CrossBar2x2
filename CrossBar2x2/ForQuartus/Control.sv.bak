module Control
#(parameter N = 1'b0)
(
	output 	req, cmd, m0ack, m1ack, muxsdata, tris, muxsaddr, muxm0, muxm1,
	input 	m0addr, m1addr, m0req, m1req, m0cmd, m1cmd, ack, clk, reset);

enum logic [1:0] {waitreq, waitack, wr} state = waitreq, next = waitreq; // создание типа данных для регистра, указывающего с каким мастером работает slave
enum bit {prtm0, prtm1} prt = prtm0; // создание типа данных для состояний КА, обрабатывающего запросы для определённого slave

logic statework, prt0, prt1; 	// вспомогательные переменные(statework 1, если КА находится в одном из этапов транзакции;
										//prt0 1, если в данный момент времени обрабатывется запрос нулевого мастера или приоритет след. операции пренадлежит ему;
										//prt1 1, если в данный момент времени обрабатывется запрос первого мастера или приоритет след. операции пренадлежит ему)

assign prt0 = (prt == prtm0);										// функции вспомогательных элементов
assign prt1 = (prt == prtm1);
assign statework = ((state == waitreq) | (state == wr)); 

assign req = statework & (m0req & prt0 | m1req & prt1);	//функции выходов
assign cmd = statework & (m0cmd & prt0 | m1cmd & prt1);
assign m0ack = statework & ack & prt0;
assign m1ack = statework & ack & prt1;
assign muxsdata = prt1;
assign muxsaddr = prt1;
assign tris = statework & (prt0 & m0cmd | prt1 & m1cmd);	//muxm0 и muxm1 идут не напрямую к мультиплексору, а сигнализируют активной единицей
assign muxm0 = statework & prt0;									//то, что сейчас обрабатывается запрос этого мастера, а схему для сигнала мультиплексору
assign muxm1 = statework & prt1;									//нужно сделать в основном модуле



always_ff @(posedge clk or posedge reset) 		// настройка сброса и переключения КА
	if (reset)
		state <= waitreq;
	else
		state <= next;

always_ff @(posedge clk or posedge reset) 		// создание условий выбора запроса для slave
	if (reset)
		prt <= prtm0;
	else
	begin
		if (prt0 & (state == wr))
		begin
			if (m0req & (m0addr == N) & !m1req)
				prt <= prtm0;
			else
				prt <= prtm1;
		end
		else if (prt1 & (state == wr))
		begin
			if (!m0req  & m1req & (m1addr == N))
				prt <= prtm1;
			else
				prt <= prtm0;
		end
		else if (prt0 & (state == waitreq))
		begin
			if (!m0req & m1req & (m1addr == N))
				prt <= prtm1;
			else
				prt <= prtm0;
		end
		else if (prt1 & (state == waitreq))
		begin
			if (!m1req & m0req & (m0addr == N))
				prt <= prtm0;
			else
				prt <= prtm1;
		end
		else
			prt <= prt;
	end

always_comb							// кодирование КС, определяющей следующее состояние КА
	if (state == waitreq)
	begin
		if (m0req & (m0addr == N) | m1req & (m1addr == N))
			next = waitack;
		else
			next = waitreq;
	end
	else if (state == waitack)
	begin
		if (ack)
			next = wr;
		else
			next = waitack;
	end
	else if (state == wr)
	begin
		if (m0req & (m0addr == N) | m1req & (m1addr == N))
			next = waitack;
		else
			next = waitreq;
	end
	else
		next = waitreq;


endmodule 