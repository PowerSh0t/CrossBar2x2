module CrossBar 
#(parameter M = 1, N = 0)
(
	output 	req, cmd, m0ack, m1ack,
	input 	[M-1:0] m0addr, m1addr,
	input 	m0req, m1req, m0cmd, m1cmd, ack, clk, reset);

enum state_slave {waitreq, waitack, wr}; // создание типа для регистра, указывающего с каким мастеромработает slave
enum priority_req {prtm0, prtm1}; // создание типа для состояний КА, обрабатывающего зхапросы для определённого slave

logic state_slave [1:0]state = waireq, next = waireq; // создание переменных КА
logic priority_req prt = prtm0; // создание регистра, отвечающего за выбор запроса

always_ff @(posedge clk or posedge reset) // носройка сброса и переключения
	if (reset) 
		state <= waitreq;
	else
		state <= next;

always_ff @(posedge clk or posedge reset) // создание условий выбора запроса для slave
{
	if (reset)
		prt <= prtm0;
	else
		if ((prt == prtm0) & (state == wr))
		{
			if (m0req & (m0addr == N) & !m1req)
				prt <= prtm0;
			else
				prt <= prtm1;
		}
		else if ((prt == prtm1) & (state == wr))
		{
			if (!m0req  & m1req & (m1addr == N))
				prt <= prtm1;
			else
				prt <= prtm0;
		}
		else if ((prt == prtm0) & (state == waitreq))
		{
			if (!m0req & m1req & (m1addr == N))
				prt <= prtm1;
			else
				prt <= prtm0;
		}
		else if ((prt == prtm1) & (state == waitreq))
		{
			if (!m1req & m0req & (m0addr == N))
				prt <= prtm0;
			else
				prt <= prtm1;
		}
		else
			prt <= prt;
}